### 发布订阅模式
> - 发布订阅模式包含三个：调度中心，发布者，订阅者；
> - 发布者和订阅者通过`调度中心`实现低耦合；
```ecmascript 6
class Envent{
  constructor() {
    this.arr={};
  }
  on(type,fn){
    if(!this.arr[type]){
      this.arr[type]=[];
    }
    this.arr[type].push(fn);
  }
  emit(type,...args){
    if(!arr[type]){
      throw '无该订阅者'
    }else{
      arr[type].foreach(item=>{
        item.call(this,...args)
      })
    }
  }
}
let envent=new Envent();
envent.on('data',function() {
  console.log("调用了data");
});
envent.emit('data',"11","22");

```
### 观察者模式
> - 观察者模式：包含两个对象；1.观察者，2.被观察者
> - 观察者：需要有一个自更新方法
> - 被观察者 要维护一个观察者对象数组，并包含有一个通知方法；
```ecmascript 6
class Watcher{
  constructor(cb) {
    if (typeof cb === 'function') {
      this.cb = cb
    } else {
      throw new Error('Observer构造器必须传入函数类型！')
    }
  }
  update(){
    this.cb();
  }
}
class UnderWatch {
  constructor() {
    this.arr=[];
  }
  addWatcher(w){
    this.arr.push(w);
  }
  notice(){
    this.arr.forEach(item=>{
      item.update();
    })
  }
}
let watcher_One=new Watcher(function (args) {
  console.log('第一个被观察者更新了');
});
let watcher_Two=new Watcher(function (args) {
  console.log('第二个被观察者更新了');
});
let underWatch=new UnderWatch();
underWatch.addWatcher(watcher_One);
underWatch.addWatcher(watcher_Two);
underWatch.notice();
```